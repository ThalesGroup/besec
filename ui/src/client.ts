//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import moment from 'moment'
export class ClientBase {
    // Get an up to date ID token - set by the caller
    // If null, no authorization header is included in requests
    getIdToken: (() => Promise<string>) | null = null

    protected async transformOptions(options: { headers?: any }) {
        // should be RequestInit, but it doesn't actually appear to be - it's just an object

        if (options.headers && this.getIdToken) {
            options.headers['Authorization'] = 'Bearer ' + (await this.getIdToken())
        }
        return Promise.resolve(options)
    }
}

export class Client extends ClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return OK
     */
    listPracticesVersions(): Promise<string[]> {
        let url_ = this.baseUrl + "/practices";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processListPracticesVersions(_response);
        });
    }

    protected processListPracticesVersions(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param version The version, or the special value "latest".
     * @return OK
     */
    getPractices(version: string): Promise<GotPractices> {
        let url_ = this.baseUrl + "/practices/{version}";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPractices(_response);
        });
    }

    protected processGetPractices(response: Response): Promise<GotPractices> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GotPractices.fromJS(resultData200);
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    createPlan(body: Body | null | undefined): Promise<Anonymous> {
        let url_ = this.baseUrl + "/plan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreatePlan(_response);
        });
    }

    protected processCreatePlan(response: Response): Promise<Anonymous> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Anonymous.fromJS(resultData201);
            return result201;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return OK
     */
    getPlan(id: string): Promise<Anonymous2> {
        let url_ = this.baseUrl + "/plan/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPlan(_response);
        });
    }

    protected processGetPlan(response: Response): Promise<Anonymous2> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Anonymous2.fromJS(resultData200);
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createPlanRevision(body: Body | null | undefined, id: string): Promise<string> {
        let url_ = this.baseUrl + "/plan/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreatePlanRevision(_response);
        });
    }

    protected processCreatePlanRevision(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return Deleted
     */
    deletePlan(id: string): Promise<void> {
        let url_ = this.baseUrl + "/plan/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeletePlan(_response);
        });
    }

    protected processDeletePlan(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return OK
     */
    getPlanVersions(id: string): Promise<RevisionVersion[]> {
        let url_ = this.baseUrl + "/plan/{id}/versions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPlanVersions(_response);
        });
    }

    protected processGetPlanVersions(response: Response): Promise<RevisionVersion[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RevisionVersion.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return OK
     */
    getPlanRevision(id: string, revId: string): Promise<PlanDetails> {
        let url_ = this.baseUrl + "/plan/{id}/revision/{revId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (revId === undefined || revId === null)
            throw new Error("The parameter 'revId' must be defined.");
        url_ = url_.replace("{revId}", encodeURIComponent("" + revId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPlanRevision(_response);
        });
    }

    protected processGetPlanRevision(response: Response): Promise<PlanDetails> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlanDetails.fromJS(resultData200);
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return OK
     */
    getPlanRevisionPracticeResponses(id: string, revId: string): Promise<PracticeResponses> {
        let url_ = this.baseUrl + "/plan/{id}/revision/{revId}/responses";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (revId === undefined || revId === null)
            throw new Error("The parameter 'revId' must be defined.");
        url_ = url_.replace("{revId}", encodeURIComponent("" + revId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPlanRevisionPracticeResponses(_response);
        });
    }

    protected processGetPlanRevisionPracticeResponses(response: Response): Promise<PracticeResponses> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PracticeResponses.fromJS(resultData200);
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return OK
     */
    listProjects(): Promise<Project[]> {
        let url_ = this.baseUrl + "/project";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processListProjects(_response);
        });
    }

    protected processListProjects(response: Response): Promise<Project[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Project.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    createProject(body: ProjectDetails | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/project";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateProject(_response);
        });
    }

    protected processCreateProject(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return result201;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return OK
     */
    getProject(id: string): Promise<Project> {
        let url_ = this.baseUrl + "/project/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProject(_response);
        });
    }

    protected processGetProject(response: Response): Promise<Project> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Project.fromJS(resultData200);
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateProject(body: ProjectDetails | null | undefined, id: string): Promise<void> {
        let url_ = this.baseUrl + "/project/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateProject(_response);
        });
    }

    protected processUpdateProject(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return Deleted
     */
    deleteProject(id: string): Promise<void> {
        let url_ = this.baseUrl + "/project/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteProject(_response);
        });
    }

    protected processDeleteProject(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return OK
     */
    getAuthConfig(): Promise<AuthConfig> {
        let url_ = this.baseUrl + "/auth";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAuthConfig(_response);
        });
    }

    protected processGetAuthConfig(response: Response): Promise<AuthConfig> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthConfig.fromJS(resultData200);
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return OK
     */
    loggedIn(): Promise<void> {
        let url_ = this.baseUrl + "/auth";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processLoggedIn(_response);
        });
    }

    protected processLoggedIn(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("No access, access requested, invalid ID token, or internal error", status, _responseText, _headers, resultdefault);
            });
        }
    }
}

/** The API representation of a practice, a specification of tasks to perform. Note this is not identical to the file representation of a practice - see schema.json for that. */
export class Practice implements IPractice {
    /** If a practice has qualifying questions, then it will also need a condition explaining how to interpret the answers to those questions.
If the practice always applies, then don't specify this.
The syntax is a boolean expression, formed of question ids, !, &&, || and (brackets). */
    condition?: string | undefined;
    /** The internal practice name. Use camelCase. */
    id!: string;
    /** A description of a project that doesn't meet level 1 of the practice */
    level0?: Level0 | undefined;
    /** The user-facing name of this practice */
    name!: string;
    /** Optional user-facing notes about this practice, for example to explain any terminology used in the questions. */
    notes?: string | undefined;
    /** A page describing this practice in more detail, or providing additional guidance. */
    page?: string | undefined;
    /** A list of qualifying questions, that determine whether this practice applies at all to the project. */
    questions?: Question[] | undefined;
    /** The core of the practice - this is the list of things teams need to do.
The order matters - what is likely to be a more important task should come before a less important task. */
    tasks!: Task[];

    constructor(data?: IPractice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tasks = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.condition = _data["condition"];
            this.id = _data["id"];
            this.level0 = _data["level0"] ? Level0.fromJS(_data["level0"]) : <any>undefined;
            this.name = _data["name"];
            this.notes = _data["notes"];
            this.page = _data["page"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(Question.fromJS(item));
            }
            if (Array.isArray(_data["tasks"])) {
                this.tasks = [] as any;
                for (let item of _data["tasks"])
                    this.tasks!.push(Task.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Practice {
        data = typeof data === 'object' ? data : {};
        let result = new Practice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["condition"] = this.condition;
        data["id"] = this.id;
        data["level0"] = this.level0 ? this.level0.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["notes"] = this.notes;
        data["page"] = this.page;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        if (Array.isArray(this.tasks)) {
            data["tasks"] = [];
            for (let item of this.tasks)
                data["tasks"].push(item.toJSON());
        }
        return data;
    }
}

/** The API representation of a practice, a specification of tasks to perform. Note this is not identical to the file representation of a practice - see schema.json for that. */
export interface IPractice {
    /** If a practice has qualifying questions, then it will also need a condition explaining how to interpret the answers to those questions.
If the practice always applies, then don't specify this.
The syntax is a boolean expression, formed of question ids, !, &&, || and (brackets). */
    condition?: string | undefined;
    /** The internal practice name. Use camelCase. */
    id: string;
    /** A description of a project that doesn't meet level 1 of the practice */
    level0?: Level0 | undefined;
    /** The user-facing name of this practice */
    name: string;
    /** Optional user-facing notes about this practice, for example to explain any terminology used in the questions. */
    notes?: string | undefined;
    /** A page describing this practice in more detail, or providing additional guidance. */
    page?: string | undefined;
    /** A list of qualifying questions, that determine whether this practice applies at all to the project. */
    questions?: Question[] | undefined;
    /** The core of the practice - this is the list of things teams need to do.
The order matters - what is likely to be a more important task should come before a less important task. */
    tasks: Task[];
}

export class Question implements IQuestion {
    /** A set of allowed answers. */
    answers?: any[] | undefined;
    /** A reference to be able to refer to the question.
Can be omitted if there is only one question in a task, in which case the question ID defaults to the task ID.
Must be unique within a practice. */
    id?: string | undefined;
    /** Whether to allow N/A as an answer. */
    na?: boolean | undefined;
    /** The question to ask */
    text!: string;

    constructor(data?: IQuestion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.na = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(item);
            }
            this.id = _data["id"];
            this.na = _data["na"] !== undefined ? _data["na"] : true;
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): Question {
        data = typeof data === 'object' ? data : {};
        let result = new Question();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item);
        }
        data["id"] = this.id;
        data["na"] = this.na;
        data["text"] = this.text;
        return data;
    }
}

export interface IQuestion {
    /** A set of allowed answers. */
    answers?: any[] | undefined;
    /** A reference to be able to refer to the question.
Can be omitted if there is only one question in a task, in which case the question ID defaults to the task ID.
Must be unique within a practice. */
    id?: string | undefined;
    /** Whether to allow N/A as an answer. */
    na?: boolean | undefined;
    /** The question to ask */
    text: string;
}

/** A self-contained description of an activity that will improve product security. */
export class Task implements ITask {
    /** The full definition of what the task is. Try to include *why* this is a useful thing to do. */
    description!: string;
    /** A reference for the task, unique within the practice, not visible to users. Use camelCase. */
    id!: string;
    /** If a team is performing all of the tasks of a given level, their maturity rating for this practice is considered to be at that level.
Level 5 is reserved for teams going beyond the activities described in the practice.
If there are less than four levels, the order they should be introduced is: 4, 1, 2, 3. */
    level!: number;
    /** Questions to determine whether or not the team already does this task.
If the team answer yes to all of these questions, then we assume this task is being performed. */
    questions!: Question[];
    /** A short summary of the task. Try and use the imperative tense. */
    title!: string;

    constructor(data?: ITask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.questions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.id = _data["id"];
            this.level = _data["level"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(Question.fromJS(item));
            }
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): Task {
        data = typeof data === 'object' ? data : {};
        let result = new Task();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        data["level"] = this.level;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        data["title"] = this.title;
        return data;
    }
}

/** A self-contained description of an activity that will improve product security. */
export interface ITask {
    /** The full definition of what the task is. Try to include *why* this is a useful thing to do. */
    description: string;
    /** A reference for the task, unique within the practice, not visible to users. Use camelCase. */
    id: string;
    /** If a team is performing all of the tasks of a given level, their maturity rating for this practice is considered to be at that level.
Level 5 is reserved for teams going beyond the activities described in the practice.
If there are less than four levels, the order they should be introduced is: 4, 1, 2, 3. */
    level: number;
    /** Questions to determine whether or not the team already does this task.
If the team answer yes to all of these questions, then we assume this task is being performed. */
    questions: Question[];
    /** A short summary of the task. Try and use the imperative tense. */
    title: string;
}

export class GotPractices implements IGotPractices {
    version!: string;
    /** The practices indexed by their ID */
    practices!: { [key: string]: Practice; };

    constructor(data?: IGotPractices) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.practices = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            if (_data["practices"]) {
                this.practices = {} as any;
                for (let key in _data["practices"]) {
                    if (_data["practices"].hasOwnProperty(key))
                        (<any>this.practices)![key] = _data["practices"][key] ? Practice.fromJS(_data["practices"][key]) : new Practice();
                }
            }
        }
    }

    static fromJS(data: any): GotPractices {
        data = typeof data === 'object' ? data : {};
        let result = new GotPractices();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        if (this.practices) {
            data["practices"] = {};
            for (let key in this.practices) {
                if (this.practices.hasOwnProperty(key))
                    (<any>data["practices"])[key] = this.practices[key] ? this.practices[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IGotPractices {
    version: string;
    /** The practices indexed by their ID */
    practices: { [key: string]: Practice; };
}

/** The plan with the details from its latest revision */
export class Plan implements IPlan {
    readonly id!: string;
    attributes!: PlanDetails;

    constructor(data?: IPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.attributes = new PlanDetails();
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.attributes = _data["attributes"] ? PlanDetails.fromJS(_data["attributes"]) : new PlanDetails();
        }
    }

    static fromJS(data: any): Plan {
        data = typeof data === 'object' ? data : {};
        let result = new Plan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["attributes"] = this.attributes ? this.attributes.toJSON() : <any>undefined;
        return data;
    }
}

/** The plan with the details from its latest revision */
export interface IPlan {
    id: string;
    attributes: PlanDetails;
}

/** The high level part of a plan, excluding the individual answers */
export class PlanDetails implements IPlanDetails {
    /** The date this plan applies to (ISO short format) */
    date!: string;
    /** When a plan is (believed to be) finished it is committed */
    committed!: boolean;
    /** The IDs of the projects to which this plan applies */
    projects!: string[];
    /** Optional notes about this plan, for example further clarification on the project/team context. */
    notes?: string | undefined;
    /** The calculated maturity level for each of the plan's practices */
    readonly maturity!: { [key: string]: number; };

    constructor(data?: IPlanDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.committed = false;
            this.projects = [];
            this.maturity = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"];
            this.committed = _data["committed"] !== undefined ? _data["committed"] : false;
            if (Array.isArray(_data["projects"])) {
                this.projects = [] as any;
                for (let item of _data["projects"])
                    this.projects!.push(item);
            }
            this.notes = _data["notes"];
            if (_data["maturity"]) {
                (<any>this).maturity = {} as any;
                for (let key in _data["maturity"]) {
                    if (_data["maturity"].hasOwnProperty(key))
                        (<any>(<any>this).maturity)![key] = _data["maturity"][key];
                }
            }
        }
    }

    static fromJS(data: any): PlanDetails {
        data = typeof data === 'object' ? data : {};
        let result = new PlanDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["committed"] = this.committed;
        if (Array.isArray(this.projects)) {
            data["projects"] = [];
            for (let item of this.projects)
                data["projects"].push(item);
        }
        data["notes"] = this.notes;
        if (this.maturity) {
            data["maturity"] = {};
            for (let key in this.maturity) {
                if (this.maturity.hasOwnProperty(key))
                    (<any>data["maturity"])[key] = this.maturity[key];
            }
        }
        return data;
    }
}

/** The high level part of a plan, excluding the individual answers */
export interface IPlanDetails {
    /** The date this plan applies to (ISO short format) */
    date: string;
    /** When a plan is (believed to be) finished it is committed */
    committed: boolean;
    /** The IDs of the projects to which this plan applies */
    projects: string[];
    /** Optional notes about this plan, for example further clarification on the project/team context. */
    notes?: string | undefined;
    /** The calculated maturity level for each of the plan's practices */
    maturity: { [key: string]: number; };
}

export class Answer implements IAnswer {
    answer!: Answer2;
    /** Caveats; additions; or explanation of why - in particular why the answer is N/A. */
    notes?: string | undefined;

    constructor(data?: IAnswer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.answer = _data["answer"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): Answer {
        data = typeof data === 'object' ? data : {};
        let result = new Answer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["answer"] = this.answer;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IAnswer {
    answer: Answer2;
    /** Caveats; additions; or explanation of why - in particular why the answer is N/A. */
    notes?: string | undefined;
}

/** The answers to a task's questions and additional data related to planning and execution. */
export class TaskResponse implements ITaskResponse {
    /** Responses to the task questions, keyed on task ID */
    answers!: { [key: string]: Answer; };
    /** Whether this task has been chosen as a priority to work on */
    priority?: boolean | undefined;
    issues?: string[] | undefined;
    /** A description of how/where to find the current implementation of this task */
    references?: string | undefined;

    constructor(data?: ITaskResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.answers = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["answers"]) {
                this.answers = {} as any;
                for (let key in _data["answers"]) {
                    if (_data["answers"].hasOwnProperty(key))
                        (<any>this.answers)![key] = _data["answers"][key] ? Answer.fromJS(_data["answers"][key]) : new Answer();
                }
            }
            this.priority = _data["priority"];
            if (Array.isArray(_data["issues"])) {
                this.issues = [] as any;
                for (let item of _data["issues"])
                    this.issues!.push(item);
            }
            this.references = _data["references"];
        }
    }

    static fromJS(data: any): TaskResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TaskResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.answers) {
            data["answers"] = {};
            for (let key in this.answers) {
                if (this.answers.hasOwnProperty(key))
                    (<any>data["answers"])[key] = this.answers[key] ? this.answers[key].toJSON() : <any>undefined;
            }
        }
        data["priority"] = this.priority;
        if (Array.isArray(this.issues)) {
            data["issues"] = [];
            for (let item of this.issues)
                data["issues"].push(item);
        }
        data["references"] = this.references;
        return data;
    }
}

/** The answers to a task's questions and additional data related to planning and execution. */
export interface ITaskResponse {
    /** Responses to the task questions, keyed on task ID */
    answers: { [key: string]: Answer; };
    /** Whether this task has been chosen as a priority to work on */
    priority?: boolean | undefined;
    issues?: string[] | undefined;
    /** A description of how/where to find the current implementation of this task */
    references?: string | undefined;
}

export class PracticeResponse implements IPracticeResponse {
    /** Responses to the practice-level questions, keyed on question ID */
    practice?: { [key: string]: Answer; } | undefined;
    /** Responses to each task, keyed on task ID */
    tasks!: { [key: string]: TaskResponse; };

    constructor(data?: IPracticeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tasks = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["practice"]) {
                this.practice = {} as any;
                for (let key in _data["practice"]) {
                    if (_data["practice"].hasOwnProperty(key))
                        (<any>this.practice)![key] = _data["practice"][key] ? Answer.fromJS(_data["practice"][key]) : new Answer();
                }
            }
            if (_data["tasks"]) {
                this.tasks = {} as any;
                for (let key in _data["tasks"]) {
                    if (_data["tasks"].hasOwnProperty(key))
                        (<any>this.tasks)![key] = _data["tasks"][key] ? TaskResponse.fromJS(_data["tasks"][key]) : new TaskResponse();
                }
            }
        }
    }

    static fromJS(data: any): PracticeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PracticeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.practice) {
            data["practice"] = {};
            for (let key in this.practice) {
                if (this.practice.hasOwnProperty(key))
                    (<any>data["practice"])[key] = this.practice[key] ? this.practice[key].toJSON() : <any>undefined;
            }
        }
        if (this.tasks) {
            data["tasks"] = {};
            for (let key in this.tasks) {
                if (this.tasks.hasOwnProperty(key))
                    (<any>data["tasks"])[key] = this.tasks[key] ? this.tasks[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IPracticeResponse {
    /** Responses to the practice-level questions, keyed on question ID */
    practice?: { [key: string]: Answer; } | undefined;
    /** Responses to each task, keyed on task ID */
    tasks: { [key: string]: TaskResponse; };
}

export class PracticeResponses implements IPracticeResponses {
    /** The version of the practices used for this response */
    practicesVersion!: string;
    /** The responses to each of the practice questions, keyed on practice id */
    practiceResponses!: { [key: string]: PracticeResponse; };

    constructor(data?: IPracticeResponses) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.practiceResponses = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            this.practicesVersion = _data["practicesVersion"];
            if (_data["practiceResponses"]) {
                this.practiceResponses = {} as any;
                for (let key in _data["practiceResponses"]) {
                    if (_data["practiceResponses"].hasOwnProperty(key))
                        (<any>this.practiceResponses)![key] = _data["practiceResponses"][key] ? PracticeResponse.fromJS(_data["practiceResponses"][key]) : new PracticeResponse();
                }
            }
        }
    }

    static fromJS(data: any): PracticeResponses {
        data = typeof data === 'object' ? data : {};
        let result = new PracticeResponses();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["practicesVersion"] = this.practicesVersion;
        if (this.practiceResponses) {
            data["practiceResponses"] = {};
            for (let key in this.practiceResponses) {
                if (this.practiceResponses.hasOwnProperty(key))
                    (<any>data["practiceResponses"])[key] = this.practiceResponses[key] ? this.practiceResponses[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IPracticeResponses {
    /** The version of the practices used for this response */
    practicesVersion: string;
    /** The responses to each of the practice questions, keyed on practice id */
    practiceResponses: { [key: string]: PracticeResponse; };
}

export class Version implements IVersion {
    readonly author!: Author;
    /** The time this version was created */
    readonly time!: moment.Moment;

    constructor(data?: IVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.author = new Author();
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).author = _data["author"] ? Author.fromJS(_data["author"]) : new Author();
            (<any>this).time = _data["time"] ? moment(_data["time"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Version {
        data = typeof data === 'object' ? data : {};
        let result = new Version();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        return data;
    }
}

export interface IVersion {
    author: Author;
    /** The time this version was created */
    time: moment.Moment;
}

export class RevisionVersion implements IRevisionVersion {
    /** Plan this version is associated with */
    planId?: string | undefined;
    /** revision ID of this version */
    revId!: string;
    version!: Version;

    constructor(data?: IRevisionVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.version = new Version();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.planId = _data["planId"];
            this.revId = _data["revId"];
            this.version = _data["version"] ? Version.fromJS(_data["version"]) : new Version();
        }
    }

    static fromJS(data: any): RevisionVersion {
        data = typeof data === 'object' ? data : {};
        let result = new RevisionVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["planId"] = this.planId;
        data["revId"] = this.revId;
        data["version"] = this.version ? this.version.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRevisionVersion {
    /** Plan this version is associated with */
    planId?: string | undefined;
    /** revision ID of this version */
    revId: string;
    version: Version;
}

/** Projects are containers for plans */
export class Project implements IProject {
    readonly id!: string;
    attributes!: ProjectDetails;
    /** The plan IDs associated with this project */
    readonly plans!: string[];

    constructor(data?: IProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.attributes = new ProjectDetails();
            this.plans = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.attributes = _data["attributes"] ? ProjectDetails.fromJS(_data["attributes"]) : new ProjectDetails();
            if (Array.isArray(_data["plans"])) {
                (<any>this).plans = [] as any;
                for (let item of _data["plans"])
                    (<any>this).plans!.push(item);
            }
        }
    }

    static fromJS(data: any): Project {
        data = typeof data === 'object' ? data : {};
        let result = new Project();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["attributes"] = this.attributes ? this.attributes.toJSON() : <any>undefined;
        if (Array.isArray(this.plans)) {
            data["plans"] = [];
            for (let item of this.plans)
                data["plans"].push(item);
        }
        return data;
    }
}

/** Projects are containers for plans */
export interface IProject {
    id: string;
    attributes: ProjectDetails;
    /** The plan IDs associated with this project */
    plans: string[];
}

export class ProjectDetails implements IProjectDetails {
    /** short name */
    name!: string;
    /** Further information about the project, for example what teams and products are considered in scope */
    description?: string | undefined;

    constructor(data?: IProjectDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ProjectDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IProjectDetails {
    /** short name */
    name: string;
    /** Further information about the project, for example what teams and products are considered in scope */
    description?: string | undefined;
}

/** Authentication configuration for the deployment */
export class AuthConfig implements IAuthConfig {
    providers!: AuthProvider[];
    gcpPublicApiKey!: string;
    gcpAuthDomain!: string;
    emulatorUrl?: string | undefined;

    constructor(data?: IAuthConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.providers = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["providers"])) {
                this.providers = [] as any;
                for (let item of _data["providers"])
                    this.providers!.push(AuthProvider.fromJS(item));
            }
            this.gcpPublicApiKey = _data["gcpPublicApiKey"];
            this.gcpAuthDomain = _data["gcpAuthDomain"];
            this.emulatorUrl = _data["emulatorUrl"];
        }
    }

    static fromJS(data: any): AuthConfig {
        data = typeof data === 'object' ? data : {};
        let result = new AuthConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.providers)) {
            data["providers"] = [];
            for (let item of this.providers)
                data["providers"].push(item.toJSON());
        }
        data["gcpPublicApiKey"] = this.gcpPublicApiKey;
        data["gcpAuthDomain"] = this.gcpAuthDomain;
        data["emulatorUrl"] = this.emulatorUrl;
        return data;
    }
}

/** Authentication configuration for the deployment */
export interface IAuthConfig {
    providers: AuthProvider[];
    gcpPublicApiKey: string;
    gcpAuthDomain: string;
    emulatorUrl?: string | undefined;
}

export class AuthProvider implements IAuthProvider {
    /** The Google Identity Platform provider ID */
    id!: string;
    samlClaims?: SamlProviderClaimsMap | undefined;
    signInOptions?: SignInOptions | undefined;
    /** True if every user from this provider has access */
    whitelisted?: boolean | undefined;

    constructor(data?: IAuthProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.samlClaims = _data["samlClaims"] ? SamlProviderClaimsMap.fromJS(_data["samlClaims"]) : <any>undefined;
            this.signInOptions = _data["signInOptions"] ? SignInOptions.fromJS(_data["signInOptions"]) : <any>undefined;
            this.whitelisted = _data["whitelisted"];
        }
    }

    static fromJS(data: any): AuthProvider {
        data = typeof data === 'object' ? data : {};
        let result = new AuthProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["samlClaims"] = this.samlClaims ? this.samlClaims.toJSON() : <any>undefined;
        data["signInOptions"] = this.signInOptions ? this.signInOptions.toJSON() : <any>undefined;
        data["whitelisted"] = this.whitelisted;
        return data;
    }
}

export interface IAuthProvider {
    /** The Google Identity Platform provider ID */
    id: string;
    samlClaims?: SamlProviderClaimsMap | undefined;
    signInOptions?: SignInOptions | undefined;
    /** True if every user from this provider has access */
    whitelisted?: boolean | undefined;
}

/** A mapping from SAML claims to fields used within the app. Presence indicates this provider is a SAML provider. */
export class SamlProviderClaimsMap implements ISamlProviderClaimsMap {
    email!: string;
    name?: string | undefined;
    firstName?: string | undefined;
    surname?: string | undefined;
    department?: string | undefined;
    pictureURL?: string | undefined;

    constructor(data?: ISamlProviderClaimsMap) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.name = _data["name"];
            this.firstName = _data["firstName"];
            this.surname = _data["surname"];
            this.department = _data["department"];
            this.pictureURL = _data["pictureURL"];
        }
    }

    static fromJS(data: any): SamlProviderClaimsMap {
        data = typeof data === 'object' ? data : {};
        let result = new SamlProviderClaimsMap();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["name"] = this.name;
        data["firstName"] = this.firstName;
        data["surname"] = this.surname;
        data["department"] = this.department;
        data["pictureURL"] = this.pictureURL;
        return data;
    }
}

/** A mapping from SAML claims to fields used within the app. Presence indicates this provider is a SAML provider. */
export interface ISamlProviderClaimsMap {
    email: string;
    name?: string | undefined;
    firstName?: string | undefined;
    surname?: string | undefined;
    department?: string | undefined;
    pictureURL?: string | undefined;
}

/** Firebase signin options, original type defined at firebaseui.auth.Config['signInOptions'] */
export class SignInOptions implements ISignInOptions {
    /** User facing name for this option */
    providerName?: string | undefined;
    iconUrl?: string | undefined;
    buttonColor?: string | undefined;

    constructor(data?: ISignInOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.providerName = _data["providerName"];
            this.iconUrl = _data["iconUrl"];
            this.buttonColor = _data["buttonColor"];
        }
    }

    static fromJS(data: any): SignInOptions {
        data = typeof data === 'object' ? data : {};
        let result = new SignInOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["providerName"] = this.providerName;
        data["iconUrl"] = this.iconUrl;
        data["buttonColor"] = this.buttonColor;
        return data;
    }
}

/** Firebase signin options, original type defined at firebaseui.auth.Config['signInOptions'] */
export interface ISignInOptions {
    /** User facing name for this option */
    providerName?: string | undefined;
    iconUrl?: string | undefined;
    buttonColor?: string | undefined;
}

export class ErrorDto implements IErrorDto {
    code?: number | undefined;
    message!: string;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        return data;
    }
}

export interface IErrorDto {
    code?: number | undefined;
    message: string;
}

export class Body implements IBody {
    details!: PlanDetails;
    responses!: PracticeResponses;

    constructor(data?: IBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.details = new PlanDetails();
            this.responses = new PracticeResponses();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.details = _data["details"] ? PlanDetails.fromJS(_data["details"]) : new PlanDetails();
            this.responses = _data["responses"] ? PracticeResponses.fromJS(_data["responses"]) : new PracticeResponses();
        }
    }

    static fromJS(data: any): Body {
        data = typeof data === 'object' ? data : {};
        let result = new Body();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        data["responses"] = this.responses ? this.responses.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBody {
    details: PlanDetails;
    responses: PracticeResponses;
}

export class Anonymous implements IAnonymous {
    /** The ID of the plan */
    planId!: string;
    /** The revision ID of the initial revision */
    revisionId!: string;

    constructor(data?: IAnonymous) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.planId = _data["planId"];
            this.revisionId = _data["revisionId"];
        }
    }

    static fromJS(data: any): Anonymous {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["planId"] = this.planId;
        data["revisionId"] = this.revisionId;
        return data;
    }
}

export interface IAnonymous {
    /** The ID of the plan */
    planId: string;
    /** The revision ID of the initial revision */
    revisionId: string;
}

export class Anonymous2 implements IAnonymous2 {
    plan!: Plan;
    /** The ID of the latest revision of this plan */
    latestRevision!: string;

    constructor(data?: IAnonymous2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.plan = new Plan();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plan = _data["plan"] ? Plan.fromJS(_data["plan"]) : new Plan();
            this.latestRevision = _data["latestRevision"];
        }
    }

    static fromJS(data: any): Anonymous2 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plan"] = this.plan ? this.plan.toJSON() : <any>undefined;
        data["latestRevision"] = this.latestRevision;
        return data;
    }
}

export interface IAnonymous2 {
    plan: Plan;
    /** The ID of the latest revision of this plan */
    latestRevision: string;
}

export class Level0 implements ILevel0 {
    /** An optional fuller explanation */
    long?: string | undefined;
    /** short should be written so it can fill in the sentence "This project <short>." */
    short!: string;

    constructor(data?: ILevel0) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.long = _data["long"];
            this.short = _data["short"];
        }
    }

    static fromJS(data: any): Level0 {
        data = typeof data === 'object' ? data : {};
        let result = new Level0();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["long"] = this.long;
        data["short"] = this.short;
        return data;
    }
}

export interface ILevel0 {
    /** An optional fuller explanation */
    long?: string | undefined;
    /** short should be written so it can fill in the sentence "This project <short>." */
    short: string;
}

export enum Answer2 {
    Yes = "Yes",
    No = "No",
    N_A = "N/A",
    Unanswered = "Unanswered",
}

export class Author implements IAuthor {
    /** The user's display name */
    name!: string;
    /** A site-wide unique ID */
    uid!: string;
    /** A profile image */
    pictureUrl?: string | undefined;

    constructor(data?: IAuthor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.uid = _data["uid"];
            this.pictureUrl = _data["pictureUrl"];
        }
    }

    static fromJS(data: any): Author {
        data = typeof data === 'object' ? data : {};
        let result = new Author();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["uid"] = this.uid;
        data["pictureUrl"] = this.pictureUrl;
        return data;
    }
}

export interface IAuthor {
    /** The user's display name */
    name: string;
    /** A site-wide unique ID */
    uid: string;
    /** A profile image */
    pictureUrl?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

// due to nswag issue #1859
// we've set  "importRequiredTypes": false in the nswag config
// and add the imports here instead using ES6 syntax